## 영속성 컨텍스트
* 엔티티를 영구 저장하는 환경
* 1차 캐시 동일성(identity) 보장
* 트랜잭션을 지원하는 쓰기 지연 (transactional write-behind)
* 변경 감지(Dirty Checking) 지연 로딩(Lazy Loading)

### 1차 캐시
* key = @Id value = 엔티티 객체인 map 형태 (스냅샷도 존재)
* 데이터 조회 시 영속성 컨텍스트에서 1차 캐시 확인 후 있으면 조회  
* 없으면 db 조회 후 값을 가져오고 1차 캐시에 저장
* 한 트랜잭션 안에서 동작하기 떄문에 큰 성능 도움은 되지 않음

### 쓰기 지연 SQL 저장소
```em.persist();```시 1차 캐시 생성과 쓰기 지연 SQL 저장소에 insert 쿼리 등록 커밋 시 db에 SQL 전송

### 스냅샷
* 1차 캐시에 처음으로 들어온 값을 스냅샷에 저장
* 커밋 시점에 내부적으로 ```flush();``` 엔티티와 스냅샷 비교
* 데이터가 변경 되었으면 update 쿼리를 쓰기 지연 SQL 저장소에 등록

## 벌크 연산
벌크 연산은 영속성 컨텍스트를 무시하고 데이터베이스에 직접 쿼리
* 벌크 연산을 먼저 실행
* 벌크 연산 수행 후 영속성 컨텍스트 초기화  
* 벌크 연산 후 영속성 컨텍스트를 초기화 하지 않을 경우 정합성에 맞지 않음

## 프록시
프록시 객체를 초기화 할 때, 프록시 객체가 실제 엔티티로 바뀌는 것은 아님, 초기화되면 프록시 객체를 통해서 실제 엔티티에 접근 가능

## 고아 객체  
* 참조가 제거된 엔티티는 다른 곳에서 참조하지 않는 고아 객체로 보고 삭제하는 기능
* 특정 엔티티가 개인 소유할 때 사용  
~~~
CascadeType.ALL + orphanRemovel=true
~~~
두 옵션을 모두 활성화 하면 부모 엔티티를 통해서 자식의 생명 주기를 관리할 수 있음

orphanRemoval은 자식을 부모 컬렉션에서 삭제
cascade=DELETE는 부모를 삭제했을 때 연결된 자식 삭제  

## 임베디드 타입 
* @Embeddedable : 값 타입을 정의하는 곳에 표시  
* @Embedded : 값 타입을 사용하는 곳에 표시  
(둘 중 하나만 넣어도 되지만 둘 다 넣도록 하자)  
* 기본 생성자 필수

## MapperSuperClass
* 상속관계 매핑이 아닌 공통 매핑 정보
* 직접 생성할 일이 없으므로 추상 클래스 권장

## OSIV
OSIV 전략은 트랜잭션 시작처럼 최초 데이터베이스 커넥션 시작 시점부터 API 응답이 끝날 때 까지 영속성 컨텍스트와 데이터베이스 커넥션을 유지  
지연 로딩은 영속성 컨텍스트가 살아있어야 가능하고, 영속성 컨텍스트는 기본적으로 데이터베이스 커넥션을 유지

하지만 이 전략은 너무 오랜시간동안 데이터베이스 커넥션 리소스를 사용하기 때문에, 실시간 트래픽이 중요한 애플리케이션에서는 커넥션이 모자랄 수 있음 이것은 결국 장애로 이어짐  

OSIV를 끄면 트랜잭션을 종료할 때 영속성 컨텍스트를 닫고, 데이터베이스 커넥션도 반환 따라서 커넥션 리소스를 낭비하지 않음
OSIV를 끄면 모든 지연로딩을 트랜잭션 안에서 처리해야 함 따라서 많은 지연 로딩코드를 트랜잭션 안으로 넣어야 하는 단점이 있음
