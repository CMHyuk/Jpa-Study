## 영속성 컨텍스트
* 엔티티를 영구 저장하는 환경
* 1차 캐시 동일성(identity) 보장
* 트랜잭션을 지원하는 쓰기 지연 (transactional write-behind)
* 변경 감지(Dirty Checking) 지연 로딩(Lazy Loading)

### 1차 캐시
* key = @Id value = 엔티티 객체인 map 형태 (스냅샷도 존재)
* 데이터 조회 시 영속성 컨텍스트에서 1차 캐시 확인 후 있으면 조회  
* 없으면 db 조회 후 값을 가져오고 1차 캐시에 저장
* 한 트랜잭션 안에서 동작하기 떄문에 큰 성능 도움은 되지 않음

### 쓰기 지연 SQL 저장소
```em.persist();```시 1차 캐시 생성과 쓰기 지연 SQL 저장소에 insert 쿼리 등록 커밋 시 db에 SQL 전송

### 스냅샷
* 1차 캐시에 처음으로 들어온 값을 스냅샷에 저장
* 커밋 시점에 내부적으로 ```flush();``` 엔티티와 스냅샷 비교
* 데이터가 변경 되었으면 update 쿼리를 쓰기 지연 SQL 저장소에 등록

## 벌크 연산
벌크 연산은 영속성 컨텍스트를 무시하고 데이터베이스에 직접 쿼리
* 벌크 연산을 먼저 실행
* 벌크 연산 수행 후 영속성 컨텍스트 초기화  
* 벌크 연산 후 영속성 컨텍스트를 초기화 하지 않을 경우 정합성에 맞지 않음
